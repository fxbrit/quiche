diff --git a/quiche/quic/core/quic_connection.cc b/quiche/quic/core/quic_connection.cc
index 9d4f882e..76afe861 100644
--- a/quiche/quic/core/quic_connection.cc
+++ b/quiche/quic/core/quic_connection.cc
@@ -308,7 +308,7 @@ QuicConnection::QuicConnection(
           arena_.New<MultiPortProbingAlarmDelegate>(this), &arena_)),
       visitor_(nullptr),
       debug_visitor_(nullptr),
-      packet_creator_(server_connection_id, &framer_, random_generator_, this),
+      packet_creator_(server_connection_id, &framer_, random_generator_, this, clock_),
       last_received_packet_info_(clock_->ApproximateNow()),
       sent_packet_manager_(perspective, clock_, random_generator_, &stats_,
                            GetDefaultCongestionControlType()),
@@ -1455,9 +1455,12 @@ bool QuicConnection::OnAckFrameStart(QuicPacketNumber largest_acked,
     return false;
   }
   processing_ack_frame_ = true;
+  // Possible RTT update via QuicSentPacketManager.
   sent_packet_manager_.OnAckFrameStart(
       largest_acked, ack_delay_time,
       idle_network_detector_.time_of_last_received_packet());
+  packet_creator_.MaybeUpdateLatestRtt(
+    sent_packet_manager_.GetRttStats()->latest_rtt());
   return true;
 }
 
@@ -2495,7 +2498,9 @@ QuicConsumedData QuicConnection::SendStreamData(QuicStreamId id,
   // a SHLO from the server, leading to two different decrypters at the
   // server.)
   ScopedPacketFlusher flusher(this);
-  return packet_creator_.ConsumeData(id, write_length, offset, state);
+  return packet_creator_.ConsumeData(
+      id, write_length, offset, state,
+      sent_packet_manager_.GetRttStats()->latest_rtt());
 }
 
 bool QuicConnection::SendControlFrame(const QuicFrame& frame) {
@@ -3464,6 +3469,7 @@ bool QuicConnection::WritePacket(SerializedPacket* packet) {
       // a normal(non-GSO) packet, so the kernel can return EMSGSIZE and we will
       // not close the connection.
       if (is_mtu_discovery && writer_->IsBatchMode()) {
+        QUIC_DVLOG(1) << ENDPOINT << "Using batch mode.";
         result = writer_->Flush();
       }
       break;
@@ -7059,8 +7065,11 @@ void QuicConnection::OnMultiPortPathProbingSuccess(
   if (multi_port_stats_ != nullptr) {
     auto now = clock_->Now();
     auto time_delta = now - start_time;
+    // Direct RTT update without going through QuicSentPacketManager.
     multi_port_stats_->rtt_stats.UpdateRtt(time_delta, QuicTime::Delta::Zero(),
                                            now);
+    packet_creator_.MaybeUpdateLatestRtt(
+      sent_packet_manager_.GetRttStats()->latest_rtt());
     if (is_path_degrading_) {
       multi_port_stats_->rtt_stats_when_default_path_degrading.UpdateRtt(
           time_delta, QuicTime::Delta::Zero(), now);
diff --git a/quiche/quic/core/quic_dispatcher.cc b/quiche/quic/core/quic_dispatcher.cc
index 0f8c1abf..7bd11fa4 100644
--- a/quiche/quic/core/quic_dispatcher.cc
+++ b/quiche/quic/core/quic_dispatcher.cc
@@ -158,7 +158,7 @@ class StatelessConnectionTerminator {
                 /*unused*/ QuicTime::Zero(), Perspective::IS_SERVER,
                 /*unused*/ kQuicDefaultConnectionIdLength),
         collector_(helper->GetStreamSendBufferAllocator()),
-        creator_(server_connection_id, &framer_, &collector_),
+        creator_(server_connection_id, &framer_, &collector_, nullptr),
         time_wait_list_manager_(time_wait_list_manager) {
     framer_.set_data_producer(&collector_);
     // Always set encrypter with original_server_connection_id.
diff --git a/quiche/quic/core/quic_framer.cc b/quiche/quic/core/quic_framer.cc
index 8a506fdf..b4b3a21f 100644
--- a/quiche/quic/core/quic_framer.cc
+++ b/quiche/quic/core/quic_framer.cc
@@ -2246,8 +2246,9 @@ bool QuicFramer::AppendIetfHeaderTypeByte(const QuicPacketHeader& header,
         PacketNumberLengthToOnWireValue(header.packet_number_length));
   } else {
     type = static_cast<uint8_t>(
-        FLAGS_FIXED_BIT | (current_key_phase_bit_ ? FLAGS_KEY_PHASE_BIT : 0) |
+        FLAGS_FIXED_BIT | (header.spin_bit ? SPIN_BIT : 0) | (current_key_phase_bit_ ? FLAGS_KEY_PHASE_BIT : 0) |
         PacketNumberLengthToOnWireValue(header.packet_number_length));
+        QUIC_DVLOG(1) << ENDPOINT << "Appending IETF type byte with header.spin_bit = " << header.spin_bit;
   }
   return writer->WriteUInt8(type);
 }
diff --git a/quiche/quic/core/quic_packet_creator.cc b/quiche/quic/core/quic_packet_creator.cc
index 2a0974f4..c47a8096 100644
--- a/quiche/quic/core/quic_packet_creator.cc
+++ b/quiche/quic/core/quic_packet_creator.cc
@@ -23,10 +23,12 @@
 #include "quiche/quic/core/frames/quic_path_challenge_frame.h"
 #include "quiche/quic/core/frames/quic_stream_frame.h"
 #include "quiche/quic/core/quic_chaos_protector.h"
+#include "quiche/quic/core/quic_clock.h"
 #include "quiche/quic/core/quic_connection_id.h"
 #include "quiche/quic/core/quic_constants.h"
 #include "quiche/quic/core/quic_data_writer.h"
 #include "quiche/quic/core/quic_error_codes.h"
+#include "quiche/quic/core/quic_time.h"
 #include "quiche/quic/core/quic_types.h"
 #include "quiche/quic/core/quic_utils.h"
 #include "quiche/quic/core/quic_versions.h"
@@ -104,13 +106,15 @@ class ScopedPacketContextSwitcher {
 
 QuicPacketCreator::QuicPacketCreator(QuicConnectionId server_connection_id,
                                      QuicFramer* framer,
-                                     DelegateInterface* delegate)
+                                     DelegateInterface* delegate,
+                                     const QuicClock* clock)
     : QuicPacketCreator(server_connection_id, framer, QuicRandom::GetInstance(),
-                        delegate) {}
+                        delegate, clock) {}
 
 QuicPacketCreator::QuicPacketCreator(QuicConnectionId server_connection_id,
                                      QuicFramer* framer, QuicRandom* random,
-                                     DelegateInterface* delegate)
+                                     DelegateInterface* delegate,
+                                     const QuicClock* clock)
     : delegate_(delegate),
       debug_delegate_(nullptr),
       framer_(framer),
@@ -130,7 +134,8 @@ QuicPacketCreator::QuicPacketCreator(QuicConnectionId server_connection_id,
       flusher_attached_(false),
       fully_pad_crypto_handshake_packets_(true),
       latched_hard_max_packet_length_(0),
-      max_datagram_frame_size_(0) {
+      max_datagram_frame_size_(0),
+      clock_(clock) {
   SetMaxPacketLength(kDefaultMaxPacketSize);
   if (!framer_->version().UsesTls()) {
     // QUIC+TLS negotiates the maximum datagram frame size via the
@@ -1337,7 +1342,8 @@ bool QuicPacketCreator::ConsumeRetransmittableControlFrame(
 QuicConsumedData QuicPacketCreator::ConsumeData(QuicStreamId id,
                                                 size_t write_length,
                                                 QuicStreamOffset offset,
-                                                StreamSendingState state) {
+                                                StreamSendingState state,
+                                                QuicTime::Delta latest_rtt) {
   QUIC_BUG_IF(quic_bug_10752_21, !flusher_attached_)
       << ENDPOINT
       << "Packet flusher is not attached when "
@@ -1347,6 +1353,9 @@ QuicConsumedData QuicPacketCreator::ConsumeData(QuicStreamId id,
   bool fin = state != NO_FIN;
   QUIC_BUG_IF(quic_bug_12398_17, has_handshake && fin)
       << ENDPOINT << "Handshake packets should never send a fin";
+
+  MaybeUpdateLatestRtt(latest_rtt);
+
   // To make reasoning about crypto frames easier, we don't combine them with
   // other retransmittable frames in a single packet.
   if (has_handshake && HasPendingRetransmittableFrames()) {
@@ -1685,6 +1694,7 @@ void QuicPacketCreator::FillPacketHeader(QuicPacketHeader* header) {
   header->destination_connection_id = GetDestinationConnectionId();
   header->destination_connection_id_included =
       GetDestinationConnectionIdIncluded();
+  QUIC_DVLOG(1) << ENDPOINT << "destination_connection_id: " << header->destination_connection_id;
   header->source_connection_id = GetSourceConnectionId();
   header->source_connection_id_included = GetSourceConnectionIdIncluded();
   header->reset_flag = false;
@@ -1704,12 +1714,55 @@ void QuicPacketCreator::FillPacketHeader(QuicPacketHeader* header) {
   header->length_length = GetLengthLength();
   header->remaining_packet_length = 0;
   if (!HasIetfLongHeader()) {
+    MaybeFlipSpinBit();
+    QUIC_DVLOG(1) << ENDPOINT << "Packet number: " << header->packet_number
+                  << ", Spin Bit: " << current_spin_bit_;
+    header->spin_bit = current_spin_bit_;
     return;
   }
   header->long_packet_type =
       EncryptionlevelToLongHeaderType(packet_.encryption_level);
 }
 
+void QuicPacketCreator::MaybeFlipSpinBit() {
+  QuicTime interval = spin_bit_interval_;
+  QuicTime now = clock_->Now();
+  if (now >= interval)
+    {
+      if (!latest_rtt_.IsZero())
+      {
+          spin_bit_interval_ = now + latest_rtt_;
+          QUIC_DVLOG(0) << ENDPOINT
+                        << "Measured latest_rtt_ is: " << latest_rtt_.ToDebuggingValue();
+          QUIC_DVLOG(1) << ENDPOINT
+                        << "Updating spin_bit_interval_ from: " << interval.ToDebuggingValue()
+                        << " to: " << spin_bit_interval_.ToDebuggingValue();
+          current_spin_bit_ = !current_spin_bit_;
+          QUIC_DVLOG(0) << ENDPOINT
+                        << "Inverting current_spin_bit_ from: " << !current_spin_bit_
+                        << " to: " << current_spin_bit_;
+      }
+    }
+}
+
+void QuicPacketCreator::ResetSpinBit() {
+  current_spin_bit_ = false;
+  spin_bit_interval_ = QuicTime::Zero();
+  latest_rtt_ = QuicTime::Delta::Zero();
+  QUIC_DVLOG(0) << ENDPOINT
+                << "Resetting current_spin_bit_";
+}
+
+void QuicPacketCreator::MaybeUpdateLatestRtt(QuicTime::Delta latest_rtt) {
+  if (!latest_rtt.IsZero() && latest_rtt != latest_rtt_) {
+      QUIC_DVLOG(1) << ENDPOINT
+                << "Updating latest_rtt_ from: "
+                << latest_rtt_.ToDebuggingValue()
+                << " to: " << latest_rtt.ToDebuggingValue();
+      latest_rtt_ = latest_rtt;
+  }
+}
+
 size_t QuicPacketCreator::GetSerializedFrameLength(const QuicFrame& frame) {
   size_t serialized_frame_length = framer_->GetSerializedFrameLength(
       frame, BytesFree(), queued_frames_.empty(),
@@ -2032,6 +2085,7 @@ void QuicPacketCreator::SetServerConnectionIdIncluded(
 void QuicPacketCreator::SetServerConnectionId(
     QuicConnectionId server_connection_id) {
   server_connection_id_ = server_connection_id;
+  ResetSpinBit();
 }
 
 void QuicPacketCreator::SetClientConnectionId(
diff --git a/quiche/quic/core/quic_packet_creator.h b/quiche/quic/core/quic_packet_creator.h
index 785efb14..c4e87f3f 100644
--- a/quiche/quic/core/quic_packet_creator.h
+++ b/quiche/quic/core/quic_packet_creator.h
@@ -24,10 +24,12 @@
 #include "absl/strings/string_view.h"
 #include "absl/types/optional.h"
 #include "quiche/quic/core/frames/quic_stream_frame.h"
+#include "quiche/quic/core/quic_clock.h"
 #include "quiche/quic/core/quic_coalesced_packet.h"
 #include "quiche/quic/core/quic_connection_id.h"
 #include "quiche/quic/core/quic_framer.h"
 #include "quiche/quic/core/quic_packets.h"
+#include "quiche/quic/core/quic_time.h"
 #include "quiche/quic/core/quic_types.h"
 #include "quiche/quic/platform/api/quic_export.h"
 #include "quiche/quic/platform/api/quic_flags.h"
@@ -35,6 +37,9 @@
 #include "quiche/common/quiche_circular_deque.h"
 
 namespace quic {
+
+class QuicClock;
+
 namespace test {
 class QuicPacketCreatorPeer;
 }
@@ -111,9 +116,10 @@ class QUIC_EXPORT_PRIVATE QuicPacketCreator {
   };
 
   QuicPacketCreator(QuicConnectionId server_connection_id, QuicFramer* framer,
-                    DelegateInterface* delegate);
+                    DelegateInterface* delegate, const QuicClock* clock);
   QuicPacketCreator(QuicConnectionId server_connection_id, QuicFramer* framer,
-                    QuicRandom* random, DelegateInterface* delegate);
+                    QuicRandom* random, DelegateInterface* delegate,
+                    const QuicClock* clock);
   QuicPacketCreator(const QuicPacketCreator&) = delete;
   QuicPacketCreator& operator=(const QuicPacketCreator&) = delete;
 
@@ -316,6 +322,34 @@ class QUIC_EXPORT_PRIVATE QuicPacketCreator {
 
   bool has_ack() const { return packet_.has_ack; }
 
+  // Setter method for current_spin_bit_.
+  void SetCurrentSpinBit(bool spin_bit) { current_spin_bit_ = spin_bit; }
+
+  // Getter method for current_spin_bit_.
+  bool GetCurrentSpinBit() const { return current_spin_bit_; }
+
+  // Setter method for spin_bit_interval_.
+  void SetSpinBitInterval(QuicTime interval) { spin_bit_interval_ = interval; }
+
+  // Getter method for spin_bit_interval_.
+  QuicTime GetSpinBitInterval() const { return spin_bit_interval_; }
+
+  // Setter method for latest_rtt_.
+  void SetLatestRtt(QuicTime::Delta latest_rtt) { latest_rtt_ = latest_rtt; }
+
+  // Getter method for latest_rtt_.
+  QuicTime::Delta GetLatestRtt() const { return latest_rtt_; }
+
+  // Update latest_rtt_ if needed.
+  void MaybeUpdateLatestRtt(QuicTime::Delta latest_rtt);
+
+  // Flips the Spin Bit according to the Internal Spin Bit logic.
+  void MaybeFlipSpinBit();
+
+  // After a migration the Connection ID is changed and the RTT stats are
+  // reset: according to the RFC 9000 we should reset the Spin Bit.
+  void ResetSpinBit();
+
   bool has_stop_waiting() const { return packet_.has_stop_waiting; }
 
   // Sets the encrypter to use for the encryption level and updates the max
@@ -357,7 +391,8 @@ class QUIC_EXPORT_PRIVATE QuicPacketCreator {
   // accommodate, the padding will overflow to the next packet(s).
   QuicConsumedData ConsumeData(QuicStreamId id, size_t write_length,
                                QuicStreamOffset offset,
-                               StreamSendingState state);
+                               StreamSendingState state,
+                               QuicTime::Delta latest_rtt);
 
   // Sends as many data only packets as allowed by the send algorithm and the
   // available iov.
@@ -686,6 +721,20 @@ class QUIC_EXPORT_PRIVATE QuicPacketCreator {
   // accept. There is no limit for QUIC_CRYPTO connections, but QUIC+TLS
   // negotiates this during the handshake.
   QuicByteCount max_datagram_frame_size_;
+
+  // Spin Bit value manintained internally by the endpoint.
+  bool current_spin_bit_ = false;
+
+  // Interval used for Internal Spin Bit marking. It is the sum of the
+  // current time and the latest RTT.
+  QuicTime spin_bit_interval_ = QuicTime::Zero();
+
+  // Latest RTT received from the Connection.
+  QuicTime::Delta latest_rtt_ = QuicTime::Delta::Zero();
+
+  // Clock used to compute the Internal Spin Bit marking interval.
+  const QuicClock* clock_;
+
 };
 
 }  // namespace quic
diff --git a/quiche/quic/core/quic_packets.cc b/quiche/quic/core/quic_packets.cc
index 746737b3..df609cd7 100644
--- a/quiche/quic/core/quic_packets.cc
+++ b/quiche/quic/core/quic_packets.cc
@@ -178,7 +178,8 @@ QuicPacketHeader::QuicPacketHeader()
       retry_token_length_length(quiche::VARIABLE_LENGTH_INTEGER_LENGTH_0),
       retry_token(absl::string_view()),
       length_length(quiche::VARIABLE_LENGTH_INTEGER_LENGTH_0),
-      remaining_packet_length(0) {}
+      remaining_packet_length(0),
+      spin_bit(false) {}
 
 QuicPacketHeader::QuicPacketHeader(const QuicPacketHeader& other) = default;
 
@@ -252,6 +253,9 @@ std::ostream& operator<<(std::ostream& os, const QuicPacketHeader& header) {
       os << ", remaining_packet_length: " << header.remaining_packet_length;
     }
   }
+  else{
+    os << ", spin bit: " << header.spin_bit;
+  }
   if (header.nonce != nullptr) {
     os << ", diversification_nonce: "
        << absl::BytesToHexString(
diff --git a/quiche/quic/core/quic_packets.h b/quiche/quic/core/quic_packets.h
index c26a88a3..80847e7b 100644
--- a/quiche/quic/core/quic_packets.h
+++ b/quiche/quic/core/quic_packets.h
@@ -160,6 +160,9 @@ struct QUIC_EXPORT_PRIVATE QuicPacketHeader {
 
   bool operator==(const QuicPacketHeader& other) const;
   bool operator!=(const QuicPacketHeader& other) const;
+
+  // Optional Spin Bit, used in QUIC to measure latency.
+  bool spin_bit;
 };
 
 struct QUIC_EXPORT_PRIVATE QuicPublicResetPacket {
diff --git a/quiche/quic/core/quic_types.h b/quiche/quic/core/quic_types.h
index c77f5359..87611028 100644
--- a/quiche/quic/core/quic_types.h
+++ b/quiche/quic/core/quic_types.h
@@ -614,7 +614,7 @@ enum QuicPacketHeaderTypeFlags : uint8_t {
   FLAGS_DEMULTIPLEXING_BIT = 1 << 3,
   // Bits 4 and 5: Reserved bits for short header.
   FLAGS_SHORT_HEADER_RESERVED_1 = 1 << 4,
-  FLAGS_SHORT_HEADER_RESERVED_2 = 1 << 5,
+  SPIN_BIT = 1 << 5,
   // Bit 6: the 'QUIC' bit.
   FLAGS_FIXED_BIT = 1 << 6,
   // Bit 7: Indicates the header is long or short header.
